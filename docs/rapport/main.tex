% !TEX program = pdflatex
\documentclass[a4paper,12pt]{report}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{lmodern}
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}

\usepackage{geometry}
\geometry{margin=2.5cm}

\usepackage{graphicx}
\graphicspath{{../slides/pic/}}
\usepackage{float}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{multirow}
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=blue, urlcolor=blue, citecolor=blue}

\usepackage{listings}
\usepackage{xcolor}
\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue!70!black}\bfseries,
  commentstyle=\color{gray!70},
  stringstyle=\color{green!40!black},
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny\color{gray},
  showstringspaces=false
}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning}


\title{DistCapsule : Distributeur connecté biométrique de capsules\\Projet AAA }
\author{Zhaoyu WANG \and Xinqi TANG}
\date{\today}

\begin{document}

% Page de titre sans numéro
\pagenumbering{gobble}
\begin{titlepage}
\centering
\noindent
\includegraphics[height=2.8cm]{logo-handi.png}\hfill
\includegraphics[height=2.8cm]{logo-p8.png}

\vspace{0.6cm}

{\large Rapport du Projet AAA\par}

\vspace*{1.6cm}

{\LARGE\bfseries DistCapsule \par}
\vspace{0.4cm}

\vspace{1.4cm}

{\large Zhaoyu WANG \; et \; Xinqi TANG\par}

\vspace{0.8cm}

{\large Professeurs encadrants :\\
Salvatore Anzalone et Dominique Archambault\par}

\vfill

{\large Université Paris 8\\Master Technologies et Handicaps\par}
\vspace{0.4cm}
%{\large \today\par}
\end{titlepage}

% Préliminaires (numérotation romaine)
\cleardoublepage
\pagenumbering{roman}
\pagestyle{plain}

\begin{abstract}
DistCapsule a pour objectif de transformer un présentoir à capsules (5 canaux) en un système embarqué \textbf{sécurisé et personnalisé}.
L’accès aux canaux est contrôlé par biométrie (empreinte et/ou visage) avec gestion multi-utilisateurs et hiérarchie des droits (admin / utilisateur).

L’architecture suit un modèle AAA (3-tiers) : \textbf{Android} pour l’IHM, \textbf{FastAPI} comme passerelle (authentification, orchestration et insertion en base), et \textbf{Raspberry Pi 5} comme exécutant (polling des commandes, contrôle des servos, affichage, biométrie locale).
Ce rapport synthétise les choix techniques, l’implémentation (code), la partie mécanique (fabrication 3D) et les résultats obtenus.
\end{abstract}

\cleardoublepage
\tableofcontents

% Corps du rapport (numérotation arabe)
\cleardoublepage
\pagenumbering{arabic}

\chapter{Contexte et objectifs}
\section{Constat}
Dans un espace café partagé, les capsules sont souvent mélangées ou stockées de manière dispersée, ce qui entraîne :
\begin{itemize}
  \item une occupation inutile de l'espace ;
  \item une organisation difficile (capsules mélangées, accès non contrôlé) ;
  \item une difficulté pour les utilisateurs à identifier leurs propres stocks.
\end{itemize}

\section{Objectifs et contraintes}
En s’appuyant sur le cahier des charges et sur l’implémentation finale, les objectifs sont :
\begin{itemize}
  \item transformer le présentoir en un système à \textbf{5 canaux indépendants} (logique de « boîte aux lettres ») ;
  \item supporter au moins 5 utilisateurs, avec deux rôles : \textbf{administrateur / utilisateur} ;
  \item réaliser la biométrie et le stockage \textbf{en local} (pas de cloud) pour la confidentialité ;
  \item fournir une application Android pour l’inscription, l’affectation des canaux, l’enrôlement et l’ouverture ;
  \item s’adapter aux spécificités du Raspberry Pi 5, notamment la compatibilité GPIO (puce RP1).
\end{itemize}

\chapter{Architecture globale (AAA / 3-tiers)}
\section{Rôles des composants}
Le système est structuré en trois couches :
\begin{itemize}
  \item \textbf{Android (Client)} : interface utilisateur, persistance du token, gestion des comptes et affectation visuelle des canaux.
  \item \textbf{FastAPI (Gateway)} : API REST, authentification via token, accès SQLite, mise en file des commandes (table \texttt{Pending\_Commands}).
  \item \textbf{Core Agent (Executor, Pi 5)} : polling des commandes, action matérielle (servos/écran), biométrie locale, journalisation.
\end{itemize}

\section{Schéma d'architecture}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[node distance=2.6cm, auto, thick]
    \node[draw, fill=green!20, minimum height=1.2cm, minimum width=3.2cm, align=center] (Android) {\textbf{Android}\\Client};
    \node[draw, fill=blue!20, minimum height=1.2cm, minimum width=3.4cm, align=center, right=3.5cm of Android] (API) {\textbf{FastAPI}\\Gateway};
    \node[draw, fill=red!20, minimum height=1.2cm, minimum width=3.6cm, align=center, right=3.5cm of API] (Pi) {\textbf{Raspberry Pi 5}\\Core Agent};

    \draw[<->] (Android) -- node[above] {REST / JSON} (API);
    \draw[<->] (API) -- node[above] {SQLite\,+ Polling} (Pi);
  \end{tikzpicture}
  \caption{Architecture AAA (3-tiers) de DistCapsule}
\end{figure}

\section{Flux de données (chaîne de traitement)}
Exemple de scénario : l'utilisateur demande l'ouverture d'un canal depuis l'application.
\begin{enumerate}
  \item l'application envoie \texttt{POST /command/unlock?channel=\{1..5\}} ;
  \item FastAPI insère une entrée dans \texttt{Pending\_Commands} (statut \texttt{pending}) ;
  \item le Core Agent récupère la commande la plus ancienne, passe en \texttt{processing} ;
  \item le Core Agent actionne le servo, met à jour l'écran, et journalise dans \texttt{Access\_Logs} ;
  \item la commande est marquée \texttt{completed} ; l'application peut consulter l'état des commandes d'enrôlement via \texttt{/command/poll/\{user\_id\}}.
\end{enumerate}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.92\textwidth]{data\_flow.png}
  \caption{Schéma de flux de données}
\end{figure}

\section{Réseau : topologie et mode de déploiement}
Pour fonctionner sans Internet, le Raspberry Pi 5 opère en mode point d'accès Wi-Fi :
\begin{itemize}
  \item SSID : \texttt{DistCapsule\_Box} (réseau typique \texttt{192.168.4.x}, Pi souvent \texttt{192.168.4.1}) ;
  \item API : port \texttt{8000} ;
  \item administration : liaison Ethernet \texttt{eth0} vers un PC (réseau typique \texttt{192.168.3.x}, Pi souvent \texttt{192.168.3.14}) pour SSH et diagnostic.
\end{itemize}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}[node distance=2.5cm, auto, thick]
    \node[draw, fill=green!20, minimum size=0.9cm, align=center] (Phone) {\textbf{Application}\\Android};
    \node[draw, fill=red!20, minimum width=3.2cm, minimum height=1.2cm, align=center, right=3.0cm of Phone] (Pi) {\textbf{Raspberry Pi 5}\\wlan0 (Point d'accès) + eth0};
    \node[draw, fill=blue!20, minimum size=0.9cm, align=center, right=3.0cm of Pi] (PC) {\textbf{Poste admin}\\SSH/Logs};
    \draw[<->] (Phone) -- node[above] {Wi-Fi} node[below] {192.168.4.x} (Pi);
    \draw[<->] (Pi) -- node[above] {RJ45} node[below] {192.168.3.x} (PC);
  \end{tikzpicture}
  \caption{Topologie réseau (point d'accès Wi-Fi + Ethernet)}
\end{figure}

\chapter{Matériel et câblage}
\section{Périphériques intégrés}
\begin{itemize}
  \item Contrôleur : Raspberry Pi 5 ;
  \item Actionneurs : 5 servomoteurs SG90 ;
  \item Capteurs : empreinte DY-50 (UART), Camera Module 3 (CSI) ;
  \item IHM locale : écran IPS 1.3\," ST7789 (SPI) + bouton de réveil (GPIO 26).
\end{itemize}

\section{Câblage et alimentation}
\subsection{Servos : mapping GPIO (Soft-PWM)}
L'implémentation utilise \texttt{lgpio} en PWM logiciel pour piloter 5 servos (contournement des canaux PWM matériels limités sur Pi 5 et incompatibilité RPi.GPIO) :

\begin{table}[H]
\centering
\begin{tabular}{llll}
\toprule
Canal (servo) & BCM GPIO & Broche (Pin) & Remarque \\
\midrule
1 & 18 & Pin 12 & Compatible Hard PWM , utilisé en Soft PWM \\
2 & 6  & Pin 31 & Soft PWM \\
3 & 12 & Pin 32 & Soft PWM \\
4 & 13 & Pin 33 & Soft PWM \\
5 & 19 & Pin 35 & Soft PWM \\
\bottomrule
\end{tabular}
\caption{Mapping des canaux vers GPIO (implémentation)}
\end{table}

\subsection{Écran (SPI) et empreinte (UART)}
\begin{itemize}
  \item ST7789 : SPI0 (SCLK/MOSI) + DC/RESET/BLK via GPIO ;
  \item Empreinte : \texttt{/dev/ttyAMA0} (GPIO 14/15), TX/RX croisés.
\end{itemize}

\subsection{Alimentation et stabilité}
\begin{itemize}
  \item Les servos sont alimentés par une source 5V externe, avec masse commune avec le Pi ;
  \item Un condensateur (ex. 500\,$\mu$F) est intégré pour amortir les pics de courant.
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.86\textwidth]{hardware\_wiring.jpg}
  \caption{Schéma de câblage}
\end{figure}

\chapter{Conception et fabrication 3D}
\section{Fabrication additive}
La modélisation a été réalisée de manière paramétrique avec \textbf{SolidPython2} (interface Python pour OpenSCAD), ce qui a facilité l'ajustement des tolérances et la génération des fichiers STL.

Les pièces ont été imprimées en PLA sur une durée cumulée d'environ 4 jours.
\subsection{Stratégie d'itération}
Pour limiter les itérations longues, l'ajustement dimensionnel a été validé par \textit{prototypage partiel} : au lieu d'imprimer directement les grandes pièces (base, tour), des « échantillons » (ex. encoche du servo, section de rail) ont été imprimés afin de vérifier les contraintes physiques et les tolérances. Cette méthode réduit le coût matière/temps et fiabilise les dimensions avant impression finale.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{3d\_render.png}
  \caption{Rendu 3D OpenSCAD du corps principal (structure porteuse)}
\end{figure}


\chapter{Implémentation logicielle}
\section{Core Agent (Pi 5) : boucle principale}
Le cœur du système s'exécute dans \texttt{main.py}. Principes de fonctionnement :
\begin{itemize}
  \item \textbf{SLEEP/ACTIVE} : veille par défaut (rétro-éclairage éteint), réveil par bouton ou commande applicative ;
  \item \textbf{Interrogation périodique (polling)} : lecture des commandes en base (ouverture / enrôlement / suppression) ;
  \item \textbf{Biométrie} : empreinte au premier plan, visage via un fil d'exécution en arrière-plan (file) ;
  \item \textbf{Temporisations} : mise en veille sur inactivité (\texttt{SCREEN\_TIMEOUT}) et durée maximale de session (\texttt{MAX\_SESSION\_TIME}).
\end{itemize}

\section{Passerelle FastAPI (api/server.py)}
FastAPI gère les utilisateurs, l'authentification par token et la mise en file des commandes.
\begin{itemize}
  \item \texttt{POST /users} : création (avec auto-affectation du premier canal libre) ;
  \item \texttt{POST /auth} : auto-login via token lié à l'appareil ;
  \item \texttt{POST /command/unlock}, \texttt{/command/enroll\_...} : insertion dans \texttt{Pending\_Commands}.
\end{itemize}

\section{Application Android : fonctionnalités et intégration}
L'application Android (Java) fournit l'interface utilisateur et s'intègre à l'API via des appels REST/JSON.
Fonctions principales :
\begin{itemize}
  \item \textbf{Authentification} : auto-login par token UUID persisté localement ;
  \item \textbf{Gestion des utilisateurs} : inscription, suppression (selon droits), affectation de canal ;
  \item \textbf{Opérations} : déclenchement d'ouverture de canal et d'enrôlement biométrique via commandes côté API ;
  \item \textbf{Retour d'état} : affichage des canaux et des statuts (disponible/occupé) à partir des données serveur.
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.35\textwidth]{app\_dashboard.png}
  \caption{Tableau de bord Android}
\end{figure}

\section{Base de données (SQLite)}
La base est initialisée via \texttt{tools/setup\_database.py}. Tables principales :
\begin{itemize}
  \item \texttt{Users} : identité, droits, canal, token, encodage visage (JSON), statut empreinte ;
  \item \texttt{Access\_Logs} : journal d'événements ;
  \item \texttt{Pending\_Commands} : file de commandes (pending/processing/completed).
\end{itemize}

\section{Biométrie (Visage et Empreinte)}
\begin{itemize}
  \item \textbf{Visage} : \texttt{face\_recognition} (dlib) sur flux vidéo GStreamer/libcamera.
  \item \textbf{Empreinte} : Module DY-50, stockage du modèle dans la mémoire interne du capteur (slot = ID utilisateur).
\end{itemize}

\chapter{Sécurité, confidentialité et approche RGPD}
\section{Confidentialité by design}
\begin{itemize}
  \item Les données biométriques restent \textbf{locales} (pas d'envoi vers un cloud) ;
  \item L'application et l'API n'échangent que le token et les paramètres de commande ;
  \item La suppression d'un compte entraîne la suppression des données associées (base + nettoyage côté capteur).
\end{itemize}

\section{Droits et protection}
\begin{itemize}
  \item L'API interdit la suppression du compte administrateur ;
  \item L'application isole les fonctions d'administration (affectation des canaux) des fonctions utilisateurs.
\end{itemize}

\chapter{Tests et résultats}
\section{Validation bout-en-bout}
Chaînes fonctionnelles validées :
\begin{itemize}
  \item Inscription via l'application $\rightarrow$ token $\rightarrow$ auto-login ;
  \item Enrôlement $\rightarrow$ guidage à l'écran $\rightarrow$ stockage DB/capteur ;
  \item Commande d'ouverture $\rightarrow$ insertion DB $\rightarrow$ exécution mécanique.
\end{itemize}

\section{Limites connues}
\begin{itemize}
  \item Le capteur d'empreintes peut se bloquer (UART) ; une réinitialisation (capteur et/ou service) est parfois nécessaire.
  \item En mode point d'accès, certains téléphones peuvent basculer sur les données mobiles (4G/5G) ; le réglage "Rester connecté" peut être nécessaire.
\end{itemize}

\chapter{Conclusion et perspectives}
DistCapsule est un \textbf{prototype fonctionnel} intégrant application Android, API FastAPI et exécution matérielle sur Raspberry Pi 5.
Il démontre la faisabilité d'un système embarqué connecté sécurisé, respectueux de la vie privée (approche locale) et multi-utilisateurs.

Perspectives :
\begin{itemize}
  \item Améliorer la robustesse du module d'empreintes (gestion d'erreurs UART, stratégie de réinitialisation, éventuellement changement de capteur) ;
  \item Finaliser l'assemblage 3D complet et documenter les tolérances d'impression (PLA) ;
  \item Remplacer le polling par un mécanisme push (ex. WebSockets) pour réduire la latence et la charge ;
  \item Finaliser la logique d'affectation automatique (notamment le canal 1) pour garantir la cohérence UI/API/SQLite lors d'ajouts/suppressions.
\end{itemize}

\appendix
\chapter{Références}
\begin{thebibliography}{9}
  \bibitem{fastapi} FastAPI Documentation. \url{https://fastapi.tiangolo.com/}
  \bibitem{rpi5} Raspberry Pi Documentation. \url{https://www.raspberrypi.com/documentation/}
  \bibitem{android} Android Developers. \url{https://developer.android.com/}
\end{thebibliography}

\end{document}
